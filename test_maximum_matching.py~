#!/usr/bin/env python


from collections import defaultdict, deque
from time import time
import pprint
import unittest
from  maximum_matching import *



# class Forest:
#      def __init__(self):
#           self.rootnodes = set()
#           self.allnodes = set()
#           self.parentdict = {}
#           self.rootdict = {}
#      def add_root(self, root):
#      def add_edge(self, beg_node, end_node):
#           #beg_node in forest already
#           #end_node not in forest
#      def path_to_root(self, node):
#      def bloom(self, node_1, node_2):
#           return (stem, blossom_vertices, blossom_cycle, least_common_ancestor, has_stem)
     

# class Matching:
#     #match_dict = {v: match[v] for all v in vertex_list}
#     #Note: If no match, match[v] is set to  None
#     def __init__(self, match_dict):
#          self.matchededges = set()
#          self.matchedvertices = set()
#          cardinality = 0
#          for v in match_dict:
#              if match_dict[v]!= None:
#                  self.matchedvertices.add(v)
#                  cardinality += 1
#                  self.matchededges.add((v,match_dict[v]))

    
#          self.cardinality = (cardinality//2)
#          self.matchdict = match_dict
         
         
         
#     def xor_even_path(self, even_path):
#          #even_path = [(v_0,v_1), (v_1,v_2),...,(v_{2n-1}, v_2n)]
         

#     def xor_aug_path(self, aug_path):
#          #aug_path = [(v_0,v_1), (v_1,v_2),...,(v_{n-1}, v_n)]
     


class TestForestMethods(unittest.TestCase):
     def setUp(self):
          self.forest = Forest()
          f = self.forest
          f.add_root(5)
          f.add_edge(5,1)
          f.add_edge(1,4)
          f.add_edge(1,2)
          f.add_edge(1,3)
          f.add_root(7)
          f.add_edge(7,6)
          f.add_edge(6,8)
     

     def tearDown(self):
         pass

     def test_forest_addition(self):
          #checking initial forest set up
          self.assertEqual(self.forest.rootnodes, {5,7})
          self.assertEqual(self.forest.allnodes, {5,4,2,1,7,6,8,3})
          self.assertEqual(self.forest.parentdict, {5: None, 4:1, 2:1, 1:5, 7:None, 6:7, 8:6, 3:1})
          self.assertEqual(self.forest.rootdict, {5:5, 4:5, 2:5, 1:5, 7:7, 3:5, 6:7, 8:7})

          #checking adding root nodes
          self.forest.add_root(9)
          
          self.assertEqual(self.forest.rootnodes, {5,7,9})
          self.assertEqual(self.forest.allnodes, {5,4,2,1,7,6,8,3,9})
          self.assertEqual(self.forest.parentdict, {5: None, 4:1, 2:1, 1:5, 7:None, 6:7, 8:6, 3:1, 9:None})
          self.assertEqual(self.forest.rootdict, {5:5, 4:5, 2:5, 1:5, 7:7, 3:5, 6:7, 8:7, 9:9})

          #checking adding edges
          self.forest.add_edge(9,10)
          self.forest.add_edge(9,11)
          self.forest.add_edge(1,12)

          self.assertEqual(self.forest.rootnodes, {5,7,9})
          self.assertEqual(self.forest.allnodes, {5,4,2,1,7,6,8,3,9,10,11,12})
          self.assertEqual(self.forest.parentdict,
                           {5: None, 4:1, 2:1, 1:5, 7:None,6:7, 8:6, 3:1, 9:None, 12:1, 10:9, 11:9})
          self.assertEqual(self.forest.rootdict,
                           {5:5, 4:5, 2:5, 1:5, 7:7, 3:5, 6:7, 8:7, 9:9, 10:9, 11:9, 12:5})


          
 

          

     def test_path_to_root(self):
         #checking path to roots
         self.assertEqual(self.forest.path_to_root(2), [(2,1), (1,5)])
         self.assertEqual(self.forest.path_to_root(6), [(6,7)])
         self.assertEqual(self.forest.path_to_root(7), [])

     
     def test_bloom_without_stem(self):
          pass
     
     def test_bloom_with_stem(self):
          pass

     def test_xor_even_path(self):
         pass
         

     def test_xor_aug_path(self):
          pass
          
     
          
     def test_create_quotient(self):
     #(vertices, graph_adj_dict, current_matching, blossom_vertices, least_common_ancestor):
          pass

     def test_find_even_path(self):
     #(node, blossom_cycle)
          pass

     def test_find_aug_path(self):
     #(graph_adjacency_dict, current_matching, vertices):
          pass

     def test_find_max_matching(self):
     #(graph_adjacency_dict, current_matching, vertices):
          pass

     def test_find_a_maximal_matching(self):
     #(graph_adjacency_dict,vertices):
          pass

     def test_create_graph_adjacency_dict(self):
     #(adjacency_matrix, list_of_vertices):
          pass

     def test_run_blossoms_algorithm(self):
     #(adjacency_matrix, list_of_vertices = None):
          pass

if __name__ == "__main__":
     unittest.main()
     
